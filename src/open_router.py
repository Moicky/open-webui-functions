"""
title: OpenRouter Cost Tracking
author: Moicky
author_url: https://github.com/Moicky/open-webui-functions
version: 0.1.0
required_open_webui_version: 0.3.17
license: MIT
"""

from open_webui.utils.misc import (
    get_last_assistant_message_item,
    get_messages_content,
)
from open_webui.internal.db import get_db, engine
from typing import Any, Awaitable, Callable
from pydantic import BaseModel, Field
from functools import lru_cache
from datetime import datetime
from sqlalchemy import text
from typing import Optional
from decimal import Decimal
import tiktoken
import requests
import logging
import json
import time

logger = logging.getLogger("OpenRouterTracker")
handler = logging.StreamHandler()
formatter = logging.Formatter("%(asctime)s | %(name)s | %(levelname)s | %(message)s")
handler.setFormatter(formatter)
logger.handlers = [handler]
logger.setLevel(logging.INFO)


@lru_cache()
def _fetch_models() -> list[dict]:
    try:
        resp = requests.get("https://openrouter.ai/api/v1/models", timeout=5)
        resp.raise_for_status()
        return resp.json().get("data", [])
    except Exception as exc:
        logger.warning("Failed to fetch models: %s", exc)
        return []


def _get_model_info(model_id: str) -> dict:
    models = _fetch_models()
    for m in models:
        if m.get("id") == model_id:
            return m
    return None


def _format_number(num: int, decimals: int = 0) -> str:
    """Format large numbers to use K, M suffixes for better readability."""
    if num >= 1000000:
        return f"{num/1000000:.1f}M"
    elif num >= 1000:
        return f"{num/1000:.1f}K"
    else:
        return f"{num:.{decimals}f}"


class UsagePersistenceManager:
    def __init__(self):
        self._init_db()

    def _init_db(self):
        """Initialize database and create table if it doesn't exist"""
        is_sqlite = "sqlite" in engine.url.drivername

        create_table_sql = """
            CREATE TABLE IF NOT EXISTS usage_costs (
                id INTEGER PRIMARY KEY {auto_increment},
                user_id TEXT,
                model TEXT,
                metadata TEXT,
                timestamp TIMESTAMP NOT NULL,
                input_tokens INTEGER,
                output_tokens INTEGER,
                total_cost DECIMAL(20,8)
            )
        """
        create_table_sql = create_table_sql.format(
            auto_increment=(
                "AUTOINCREMENT" if is_sqlite else "GENERATED BY DEFAULT AS IDENTITY"
            )
        )

        create_index1_sql = """
            CREATE INDEX IF NOT EXISTS idx_user_id ON usage_costs(user_id);
        """

        # Create usage_costs_by_chat table
        create_chat_costs_table_sql = """
            CREATE TABLE IF NOT EXISTS usage_costs_by_chat (
                chat_id TEXT PRIMARY KEY,
                user_id TEXT,
                total_cost DECIMAL(20,8),
                last_updated TIMESTAMP NOT NULL
            )
        """

        try:
            with get_db() as db:
                db.execute(text(create_table_sql))
                db.execute(text(create_index1_sql))
                db.execute(text(create_chat_costs_table_sql))
                db.commit()
        except Exception as e:
            logger.error(f"Database error in _init_db: {e}")
            raise

    async def log_usage_fact(
        self,
        user_id: str,
        model: str,
        metadata: str,
        input_tokens: int,
        output_tokens: int,
        total_cost: Decimal,
    ):
        """Insert a new cost record into the database"""
        timestamp = datetime.now()

        insert_sql = """
            INSERT INTO usage_costs (
                user_id, model, metadata, timestamp, input_tokens, output_tokens, total_cost
            ) VALUES (:user_id, :model, :metadata, :timestamp, :input_tokens, :output_tokens, :total_cost)
        """

        with get_db() as db:
            try:
                db.execute(
                    text(insert_sql),
                    {
                        "user_id": user_id,
                        "model": model,
                        "metadata": metadata,
                        "timestamp": timestamp,
                        "input_tokens": input_tokens,
                        "output_tokens": output_tokens,
                        "total_cost": str(total_cost),
                    },
                )
                db.commit()

            except Exception as e:
                logger.error(f"Database error in log_usage_fact: {e}")
                raise

    async def get_chat_total_cost(self, chat_id: str) -> Optional[Decimal]:
        """Get total cost for a chat"""
        if not chat_id:
            return None

        select_sql = """
            SELECT total_cost 
            FROM usage_costs_by_chat 
            WHERE chat_id = :chat_id
        """

        with get_db() as db:
            try:
                result = db.execute(text(select_sql), {"chat_id": chat_id}).fetchone()

                if result:
                    return Decimal(str(result[0]))
                return None

            except Exception as e:
                logger.error(f"Database error in get_chat_total_cost: {e}")
                raise

    async def update_chat_total_cost(
        self,
        chat_id: str,
        user_id: str,
        additional_cost: Decimal,
    ):
        """Update total cost for a chat"""
        if not chat_id:
            return

        timestamp = datetime.now()
        is_sqlite = "sqlite" in engine.url.drivername

        if is_sqlite:
            # SQLite version using ON CONFLICT
            upsert_sql = """
                INSERT INTO usage_costs_by_chat (
                    chat_id, user_id, total_cost, last_updated
                ) VALUES (
                    :chat_id, :user_id, :additional_cost, :timestamp
                )
                ON CONFLICT(chat_id) DO UPDATE SET
                    total_cost = total_cost + :additional_cost,
                    last_updated = :timestamp
            """
        else:
            # PostgreSQL version using ON CONFLICT
            upsert_sql = """
                INSERT INTO usage_costs_by_chat (
                    chat_id, user_id, user_email, total_cost, last_updated
                ) VALUES (
                    :chat_id, :user_id, :user_email, :additional_cost, :timestamp
                )
                ON CONFLICT (chat_id) DO UPDATE SET
                    total_cost = usage_costs_by_chat.total_cost + :additional_cost,
                    last_updated = :timestamp
            """

        with get_db() as db:
            try:
                db.execute(
                    text(upsert_sql),
                    {
                        "chat_id": chat_id,
                        "user_id": user_id,
                        "additional_cost": str(additional_cost),
                        "timestamp": timestamp,
                    },
                )
                db.commit()

            except Exception as e:
                logger.error(f"Database error in update_chat_total_cost: {e}")
                raise


class Filter:
    class Valves(BaseModel):
        priority: int = Field(
            default=0, description="Priority level for the filter operations."
        )
        compensation: float = Field(
            default=1.0, description="Compensation for price calculation (percent)"
        )
        context_used: bool = Field(default=True, description="Display the context used")
        elapsed_time: bool = Field(default=True, description="Display the elapsed time")
        number_of_tokens: bool = Field(
            default=True, description="Display total number of tokens"
        )
        tokens_per_sec: bool = Field(
            default=True, description="Display tokens per second metric"
        )
        costs: bool = Field(default=True, description="Display costs")

    class UserValves(BaseModel):
        context_used: bool = Field(default=True, description="Display the context used")
        elapsed_time: bool = Field(default=True, description="Display the elapsed time")
        number_of_tokens: bool = Field(
            default=True, description="Display sent & received tokens"
        )
        tokens_per_sec: bool = Field(
            default=True, description="Display tokens per second metric"
        )
        costs: bool = Field(default=True, description="Display costs")

    def __init__(self):
        self.valves = self.Valves()
        self.usage_persistence_manager = UsagePersistenceManager()
        self.start_time = None

    def get_valves(self, __user__: Optional[dict] = None) -> UserValves:
        try:
            user_valves = __user__.get("valves", {})

            user_dict = (
                user_valves.model_dump()
                if isinstance(user_valves, BaseModel)
                else user_valves
            )
            merged_valves = self.valves.model_dump()
            merged_valves.update(user_dict)
            return self.UserValves(**merged_valves)
        except:
            return self.valves

    def get_status_message(
        self,
        elapsed_time: float,
        input_tokens: int,
        output_tokens: int,
        total_tokens: int,
        cost: float,
        max_context_length: Optional[int] = None,
        total_cost: Optional[float] = None,
        __user__: Optional[dict] = None,
    ) -> str:
        valves = self.get_valves(__user__)

        stats_array = []

        if valves.context_used and max_context_length is not None:
            stats_array.append(
                f"🪙 {_format_number(total_tokens)} / {_format_number(max_context_length)}"
            )
        if valves.elapsed_time:
            if valves.tokens_per_sec:
                tokens_per_sec = output_tokens / elapsed_time if elapsed_time > 0 else 0
                stats_array.append(
                    f"⏱️ {elapsed_time:.2f}s ({_format_number(tokens_per_sec, 2)} t/s)"
                )
            else:
                stats_array.append(f"⏱️ {elapsed_time:.2f}s")
        if valves.number_of_tokens:
            stats_array.append(
                f"🔼 {_format_number(input_tokens)} / 🔽 {_format_number(output_tokens)} Tokens"
            )
        if valves.costs:
            cost_string = ""
            if float(cost) < float("0.00000001"):
                cost_string = f"💰 ${cost:.2f}"
            else:
                cost_string = f"💰 ${cost:.8f}"

            if total_cost is not None:
                cost_string = f"{cost_string} (${total_cost:.2f} total)"

            stats_array.append(cost_string)

        return " | ".join(stats_array)

    async def inlet(
        self,
        body: dict,
        __user__: Optional[dict] = None,
        __metadata__: Optional[dict] = None,
        __event_emitter__: Optional[Callable[[Any], Awaitable[None]]] = None,
    ) -> dict:
        try:
            model = body.get("model").split("/")[-1]
            enc = tiktoken.encoding_for_model(model)
        except:
            enc = tiktoken.get_encoding("cl100k_base")

        input_content = get_messages_content(body["messages"])
        self.input_tokens = len(enc.encode(input_content))

        await __event_emitter__(
            {
                "type": "status",
                "data": {
                    "description": f"Processing {_format_number(self.input_tokens)} input tokens...",
                    "done": False,
                },
            }
        )

        self.start_time = time.time()

        body["usage"] = dict(**body.get("usage", {}), include=True)
        return body

    async def outlet(
        self,
        body: dict,
        __user__: Optional[dict] = None,
        __metadata__: Optional[dict] = None,
        __event_emitter__: Optional[Callable[[Any], Awaitable[None]]] = None,
    ) -> dict:
        elapsed_time = time.time() - self.start_time
        message = get_last_assistant_message_item(body["messages"])
        if message is None:
            return body

        cost = message.get("usage", {}).get("cost", 0) * (
            1 + self.valves.compensation / 100
        )
        try:
            message["usage"]["cost"] = cost
        except:
            pass

        user_id = __user__.get("id")
        chat_id = __metadata__.get("chat_id")
        session_id = __metadata__.get("session_id")

        await __event_emitter__(
            {
                "type": "status",
                "data": {"description": "Computing total costs...", "done": False},
            }
        )

        input_tokens = message.get("usage", {}).get("prompt_tokens", 0)
        output_tokens = message.get("usage", {}).get("completion_tokens", 0)
        total_tokens = message.get("usage", {}).get("total_tokens", 0)

        max_context_length = None
        total_cost = None

        try:
            await self.usage_persistence_manager.log_usage_fact(
                user_id=__user__.get("id"),
                model=body.get("model"),
                metadata=json.dumps(
                    {
                        "chat_id": chat_id,
                        "session_id": session_id,
                    }
                ),
                input_tokens=input_tokens,
                output_tokens=output_tokens,
                total_cost=cost,
            )

            await self.usage_persistence_manager.update_chat_total_cost(
                chat_id=chat_id, user_id=user_id, additional_cost=cost
            )

            if self.valves.context_used:
                model_info = _get_model_info(body.get("model"))
                if model_info:
                    max_context_length = model_info.get("context_length")

            fetched_cost = await self.usage_persistence_manager.get_chat_total_cost(
                chat_id=chat_id
            )
            if fetched_cost is not None:
                total_cost = fetched_cost

        except Exception as e:
            logger.error(f"Error in outlet: {e}")

        await __event_emitter__(
            {
                "type": "status",
                "data": {
                    "done": True,
                    "description": self.get_status_message(
                        elapsed_time,
                        input_tokens,
                        output_tokens,
                        total_tokens,
                        cost,
                        max_context_length,
                        total_cost,
                        __user__,
                    ),
                },
            }
        )

        return body
